(module (import "Main" "MemoryBuffer" (memory 1 65536 shared)) (import "console" "log" (func $log (param i32))) (func $RequestGPUUpload (export "RequestGPUUpload") (param $SSI i32) local.get $SSI i32.const 0xffff0000 i32.and i32.const 65528 i32.or i32.const 2 i32.shl local.get $SSI i32.const 2 i32.shl i32.atomic.load i32.const 65535 i32.and i32.atomic.rmw.add drop ) (func $Allocate (export "Allocate") (param $Size i32) (param $Temporary i32) (result i32) (local $Max i32) (local $Index i32) (local $SegmentIndex i32) (local $i i32) (local $AllocationStackIndex i32) (local $AllocationHeapIndex i32) (local $Skip i32) i32.const 0 i32.const 2 i32.shl i32.load i32.const 18 i32.shr_s local.set $Max i32.const 0 local.set $Index i32.const 5 i32.const 2 i32.shl i32.atomic.load local.set $SegmentIndex block $Exit1396928344360863 block $False1396928344360863 local.get $Temporary br_if $False1396928344360863 br $Exit1396928344360863 end local.get $SegmentIndex i32.const 512 i32.add i32.const 6 i32.const 2 i32.shl i32.load i32.rem_s local.get $Max i32.const 6 i32.const 2 i32.shl i32.load i32.sub i32.add local.set $SegmentIndex end i32.const 0 local.set $i block $Exit2643600007580576 nop block $SkipLoopCondition2643600007580576 local.get $i local.get $Max i32.lt_s br_if $SkipLoopCondition2643600007580576 br $Exit2643600007580576 end loop $Continue2643600007580576 block $Exit1071834803600178 block $False1071834803600178 local.get $SegmentIndex i32.const 16 i32.shl i32.const 65534 i32.or i32.const 2 i32.shl i32.atomic.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl i32.atomic.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65534 i32.or i32.const 2 i32.shl i32.atomic.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl i32.atomic.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65534 i32.or i32.const 2 i32.shl i32.atomic.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl i32.atomic.load i32.lt_u select local.get $SegmentIndex i32.const 16 i32.shl i32.const 65535 i32.or i32.const 2 i32.shl i32.atomic.load i32.sub local.get $Size i32.const 1 i32.add i32.gt_s br_if $False1071834803600178 block $Exit2476230138293539 block $False2476230138293539 local.get $Temporary i32.eqz br_if $False2476230138293539 br $Exit2476230138293539 end block $Exit3382339020608320 block $False3382339020608320 local.get $SegmentIndex i32.const 5 i32.const 2 i32.shl i32.atomic.load i32.eq br_if $False3382339020608320 br $Exit3382339020608320 end local.get $SegmentIndex i32.const 1 i32.add local.set $Index block $Exit2286380636876521 block $False2286380636876521 local.get $Index local.get $Max i32.ge_s br_if $False2286380636876521 br $Exit2286380636876521 end local.get $Max i32.const 6 i32.const 2 i32.shl i32.load i32.sub local.set $Index end i32.const 5 i32.const 2 i32.shl local.get $Index i32.atomic.store end end local.get $i i32.const 1 i32.add local.tee $i drop drop drop local.get $SegmentIndex i32.const 1 i32.add local.tee $SegmentIndex drop block $Exit3417705470121883 block $False3417705470121883 local.get $SegmentIndex local.get $Max i32.ge_s br_if $False3417705470121883 br $Exit3417705470121883 end local.get $Max i32.const 6 i32.const 2 i32.shl i32.load i32.sub local.set $SegmentIndex end br $Exit1071834803600178 end block $Exit1005434973578072 block $SkipLoopCondition1005434973578072 local.get $SegmentIndex i32.const 16 i32.shl i32.const 65530 i32.or i32.const 2 i32.shl i32.const 0 i32.const 1 i32.atomic.rmw.cmpxchg i32.const 0 i32.ne br_if $SkipLoopCondition1005434973578072 br $Exit1005434973578072 end loop $Continue1005434973578072 local.get $SegmentIndex i32.const 16 i32.shl i32.const 65530 i32.or i32.const 2 i32.shl i32.const 1 i64.const 1000000000 memory.atomic.wait32 drop local.get $SegmentIndex i32.const 16 i32.shl i32.const 65530 i32.or i32.const 2 i32.shl i32.const 0 i32.const 1 i32.atomic.rmw.cmpxchg i32.const 0 i32.ne br_if $Continue1005434973578072 end end local.get $SegmentIndex i32.const 16 i32.shl i32.const 65529 i32.or i32.const 2 i32.shl i32.const 1 i32.atomic.rmw.add drop i32.const 0 local.set $Skip block $Exit1249946755458128 block $False1249946755458128 local.get $SegmentIndex i32.const 16 i32.shl i32.const 65531 i32.or i32.const 2 i32.shl i32.atomic.load i32.const 1 i32.eq br_if $False1249946755458128 br $Exit1249946755458128 end i32.const 1 local.set $Skip end block $Exit787392770147904 block $False787392770147904 local.get $Skip i32.eqz br_if $False787392770147904 br $Exit787392770147904 end block $Exit2133522895682621 block $False2133522895682621 local.get $SegmentIndex i32.const 16 i32.shl i32.const 65534 i32.or i32.const 2 i32.shl i32.atomic.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl i32.atomic.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65534 i32.or i32.const 2 i32.shl i32.atomic.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl i32.atomic.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65534 i32.or i32.const 2 i32.shl i32.atomic.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl i32.atomic.load i32.lt_u select local.get $SegmentIndex i32.const 16 i32.shl i32.const 65535 i32.or i32.const 2 i32.shl i32.atomic.load i32.sub local.get $Size i32.const 1 i32.add i32.le_s br_if $False2133522895682621 br $Exit2133522895682621 end i32.const 1 local.set $Skip end end block $Exit2548289873105914 block $False2548289873105914 local.get $Skip br_if $False2548289873105914 br $Exit2548289873105914 end local.get $SegmentIndex i32.const 16 i32.shl i32.const 65529 i32.or i32.const 2 i32.shl i32.const 1 i32.atomic.rmw.sub drop local.get $SegmentIndex i32.const 16 i32.shl i32.const 65530 i32.or i32.const 2 i32.shl i32.const 1 i32.const 0 i32.atomic.rmw.cmpxchg drop local.get $SegmentIndex i32.const 16 i32.shl i32.const 65530 i32.or i32.const 2 i32.shl i32.const 1 memory.atomic.notify drop local.get $i i32.const 1 i32.add local.tee $i drop local.get $SegmentIndex i32.const 1 i32.add local.tee $SegmentIndex drop block $Exit319456437242902 block $False319456437242902 local.get $SegmentIndex local.get $Max i32.ge_s br_if $False319456437242902 br $Exit319456437242902 end local.get $Max i32.const 6 i32.const 2 i32.shl i32.load i32.sub local.set $SegmentIndex end br $Continue2643600007580576 end br $Exit2643600007580576 end nop local.get $i local.get $Max i32.lt_s br_if $Continue2643600007580576 end end block $Exit21538326776446 block $False21538326776446 local.get $i local.get $Max i32.eq br_if $False21538326776446 br $Exit21538326776446 end unreachable end i32.const 0 local.set $AllocationStackIndex block $Exit663549308901822 block $False663549308901822 local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl i32.load local.get $SegmentIndex i32.const 16 i32.shl i32.const 65534 i32.or i32.const 2 i32.shl i32.load i32.lt_s br_if $False663549308901822 local.get $SegmentIndex i32.const 16 i32.shl i32.const 65534 i32.or i32.const 2 i32.shl i32.load local.set $AllocationStackIndex local.get $SegmentIndex i32.const 16 i32.shl i32.const 65534 i32.or i32.const 2 i32.shl local.get $AllocationStackIndex i32.const 1 i32.sub i32.store br $Exit663549308901822 end local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl i32.load i32.const 1 i32.add i32.store local.get $SegmentIndex i32.const 16 i32.shl local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl i32.load i32.or i32.const 2 i32.shl i32.load local.set $AllocationStackIndex local.get $SegmentIndex i32.const 16 i32.shl local.get $SegmentIndex i32.const 16 i32.shl i32.const 65533 i32.or i32.const 2 i32.shl i32.load i32.or i32.const 2 i32.shl i32.const 0 i32.store end local.get $SegmentIndex i32.const 16 i32.shl i32.const 65535 i32.or i32.const 2 i32.shl i32.load local.set $AllocationHeapIndex local.get $SegmentIndex i32.const 16 i32.shl local.get $AllocationStackIndex i32.or i32.const 2 i32.shl local.get $AllocationHeapIndex i32.store local.get $SegmentIndex i32.const 16 i32.shl i32.const 65535 i32.or i32.const 2 i32.shl local.get $SegmentIndex i32.const 16 i32.shl i32.const 65535 i32.or i32.const 2 i32.shl i32.load local.get $Size i32.add i32.store local.get $SegmentIndex i32.const 16 i32.shl local.get $AllocationHeapIndex i32.or i32.const 2 i32.shl local.get $Size i32.const 16 i32.shl local.get $AllocationStackIndex i32.const -1 i32.xor i32.const 65535 i32.and i32.or i32.store local.get $SegmentIndex i32.const 16 i32.shl i32.const 65529 i32.or i32.const 2 i32.shl i32.const 1 i32.atomic.rmw.add drop local.get $SegmentIndex i32.const 16 i32.shl i32.const 65530 i32.or i32.const 2 i32.shl i32.const 1 i32.const 0 i32.atomic.rmw.cmpxchg drop local.get $SegmentIndex i32.const 16 i32.shl i32.const 65530 i32.or i32.const 2 i32.shl i32.const 1 memory.atomic.notify drop local.get $SegmentIndex i32.const 16 i32.shl local.get $AllocationStackIndex i32.or return ) (func $SetCreate (export "SetCreate") (param $Size i32) (result i32) (local $AllocationSize i32) (local $SSI i32) (local $HeapIndex i32) (local $i i32) i32.const 3 local.get $Size i32.mul i32.const 2 i32.add local.set $AllocationSize local.get $AllocationSize i32.const 1 call $Allocate local.set $SSI local.get $SSI i32.const 0xffff0000 i32.and local.get $SSI i32.const 2 i32.shl i32.load i32.or local.set $HeapIndex local.get $HeapIndex i32.const 1 i32.add i32.const 2 i32.shl local.get $Size i32.const 65535 i32.and i32.store block $Exit4217191233147986 i32.const 2 local.set $i block $SkipLoopCondition4217191233147986 local.get $i local.get $AllocationSize i32.lt_s br_if $SkipLoopCondition4217191233147986 br $Exit4217191233147986 end loop $Continue4217191233147986 local.get $HeapIndex local.get $i i32.add i32.const 2 i32.shl i32.const 0xffffffff i32.store local.get $i i32.const 1 i32.add local.tee $i local.get $i local.get $AllocationSize i32.lt_s br_if $Continue4217191233147986 drop end end local.get $SSI return ) (func $SetAdd (export "SetAdd") (param $SSI i32) (param $Value i32) (local $HeapIndex i32) (local $I_Header i32) (local $Capacity i32) (local $I_HashTable i32) (local $I_ItemsList i32) (local $CapacityM1 i32) (local $Hash i32) (local $i i32) (local $CurrentValue i32) (local $SetItems i32) local.get $SSI i32.const 0xffff0000 i32.and local.get $SSI i32.const 2 i32.shl i32.load i32.or local.set $HeapIndex local.get $HeapIndex i32.const 1 i32.add local.set $I_Header local.get $I_Header i32.const 2 i32.shl i32.load i32.const 65535 i32.and local.set $Capacity local.get $HeapIndex i32.const 2 i32.add local.set $I_HashTable local.get $HeapIndex i32.const 2 local.get $Capacity i32.const 1 i32.shl i32.add i32.add local.set $I_ItemsList local.get $Capacity i32.const 1 i32.sub local.set $CapacityM1 local.get $Value local.set $Hash block $Exit1855651700448772 i32.const 0 local.set $i block $SkipLoopCondition1855651700448772 local.get $i local.get $Capacity i32.lt_s br_if $SkipLoopCondition1855651700448772 br $Exit1855651700448772 end loop $Continue1855651700448772 local.get $I_HashTable local.get $Hash local.get $i i32.add local.get $CapacityM1 i32.and i32.const 1 i32.shl i32.add i32.const 2 i32.shl i32.load local.set $CurrentValue block $Exit4350625478466089 block $False4350625478466089 local.get $CurrentValue local.get $Value i32.eq br_if $False4350625478466089 br $Exit4350625478466089 end nop return end block $Exit4213213904836492 block $False4213213904836492 local.get $CurrentValue i32.const 0xffffffff i32.eq br_if $False4213213904836492 br $Exit4213213904836492 end local.get $Hash local.get $i i32.add local.get $CapacityM1 i32.and local.set $Hash local.get $I_Header i32.const 2 i32.shl i32.load i32.const 16 i32.shr_s local.set $SetItems local.get $I_HashTable local.get $Hash i32.const 1 i32.shl i32.add i32.const 2 i32.shl local.get $Value i32.store local.get $I_HashTable local.get $Hash i32.const 1 i32.shl i32.const 1 i32.or i32.add i32.const 2 i32.shl local.get $SetItems i32.store local.get $I_ItemsList local.get $SetItems i32.add i32.const 2 i32.shl local.get $Value i32.store local.get $I_Header i32.const 2 i32.shl local.get $I_Header i32.const 2 i32.shl i32.load i32.const 65535 i32.and local.get $SetItems i32.const 1 i32.add i32.const 16 i32.shl i32.or i32.store nop return end local.get $i i32.const 1 i32.add local.tee $i local.get $i local.get $Capacity i32.lt_s br_if $Continue1855651700448772 drop end end unreachable ) (func $SetClear (export "SetClear") (param $SSI i32) (local $HeapIndex i32) (local $I_Header i32) (local $Capacity i32) (local $I_HashTable i32) (local $I_ItemsList i32) (local $CapacityM1 i32) (local $SetItems i32) (local $i i32) (local $Value i32) (local $Hash i32) (local $j i32) local.get $SSI i32.const 0xffff0000 i32.and local.get $SSI i32.const 2 i32.shl i32.load i32.or local.set $HeapIndex local.get $HeapIndex i32.const 1 i32.add local.set $I_Header local.get $I_Header i32.const 2 i32.shl i32.load i32.const 65535 i32.and local.set $Capacity local.get $HeapIndex i32.const 2 i32.add local.set $I_HashTable local.get $HeapIndex i32.const 2 local.get $Capacity i32.const 1 i32.shl i32.add i32.add local.set $I_ItemsList local.get $Capacity i32.const 1 i32.sub local.set $CapacityM1 local.get $I_Header i32.const 2 i32.shl i32.load i32.const 16 i32.shr_s local.set $SetItems block $Exit2851607419387370 i32.const 0 local.set $i block $SkipLoopCondition2851607419387370 local.get $i local.get $SetItems i32.lt_s br_if $SkipLoopCondition2851607419387370 br $Exit2851607419387370 end loop $Continue2851607419387370 local.get $I_ItemsList local.get $i i32.add i32.const 2 i32.shl i32.load local.set $Value local.get $Value local.set $Hash local.get $I_ItemsList local.get $i i32.add i32.const 2 i32.shl i32.const 0xffffffff i32.store block $Exit1919880513780585 i32.const 0 local.set $j block $SkipLoopCondition1919880513780585 local.get $j local.get $Capacity i32.lt_s br_if $SkipLoopCondition1919880513780585 br $Exit1919880513780585 end loop $Continue1919880513780585 block $Exit4246427853851865 block $False4246427853851865 local.get $I_HashTable local.get $Hash local.get $j i32.add local.get $CapacityM1 i32.and i32.const 1 i32.shl i32.add i32.const 2 i32.shl i32.load i32.const 0xffffffff i32.eq br_if $False4246427853851865 br $Exit4246427853851865 end br $Exit1919880513780585 end local.get $I_HashTable local.get $Hash local.get $j i32.add local.get $CapacityM1 i32.and i32.const 1 i32.shl i32.add i32.const 2 i32.shl i32.const 0xffffffff i32.store local.get $I_HashTable local.get $Hash local.get $j i32.add local.get $CapacityM1 i32.and i32.const 1 i32.shl i32.const 1 i32.or i32.add i32.const 2 i32.shl i32.const 0xffffffff i32.store local.get $j i32.const 1 i32.add local.tee $j local.get $j local.get $Capacity i32.lt_s br_if $Continue1919880513780585 drop end end local.get $i i32.const 1 i32.add local.tee $i local.get $i local.get $SetItems i32.lt_s br_if $Continue2851607419387370 drop end end local.get $I_Header i32.const 2 i32.shl local.get $I_Header i32.const 2 i32.shl i32.load i32.const 65535 i32.and i32.store ) (func $SetGet (export "SetGet") (param $SSI i32) (param $Value i32) (result i32) (local $HeapIndex i32) (local $I_Header i32) (local $Capacity i32) (local $I_HashTable i32) (local $I_ItemsList i32) (local $CapacityM1 i32) (local $i i32) (local $SetSize i32) (local $Hash i32) (local $CurrentValue i32) local.get $SSI i32.const 0xffff0000 i32.and local.get $SSI i32.const 2 i32.shl i32.load i32.or local.set $HeapIndex local.get $HeapIndex i32.const 1 i32.add local.set $I_Header local.get $I_Header i32.const 2 i32.shl i32.load i32.const 65535 i32.and local.set $Capacity local.get $HeapIndex i32.const 2 i32.add local.set $I_HashTable local.get $HeapIndex i32.const 2 local.get $Capacity i32.const 1 i32.shl i32.add i32.add local.set $I_ItemsList local.get $Capacity i32.const 1 i32.sub local.set $CapacityM1 i32.const 0 local.set $i local.get $I_Header i32.const 2 i32.shl i32.load i32.const 16 i32.shr_s local.set $SetSize block $Exit3504390173257746 block $False3504390173257746 local.get $SetSize i32.const 4 i32.lt_s br_if $False3504390173257746 br $Exit3504390173257746 end i32.const 0 local.set $i block $Exit3551888024181765 nop block $SkipLoopCondition3551888024181765 local.get $i local.get $SetSize i32.lt_s br_if $SkipLoopCondition3551888024181765 br $Exit3551888024181765 end loop $Continue3551888024181765 block $Exit837271731853194 block $False837271731853194 local.get $I_ItemsList local.get $i i32.add i32.const 2 i32.shl i32.load local.get $Value i32.eq br_if $False837271731853194 br $Exit837271731853194 end local.get $i return end local.get $i i32.const 1 i32.add local.tee $i local.get $i local.get $SetSize i32.lt_s br_if $Continue3551888024181765 drop end end i32.const 0xffffffff return end local.get $Value local.set $Hash i32.const 0 local.set $i block $Exit3638738254362715 nop block $SkipLoopCondition3638738254362715 local.get $i local.get $Capacity i32.lt_s br_if $SkipLoopCondition3638738254362715 br $Exit3638738254362715 end loop $Continue3638738254362715 local.get $I_HashTable local.get $Hash local.get $i i32.add local.get $CapacityM1 i32.and i32.const 1 i32.shl i32.add i32.const 2 i32.shl i32.load local.set $CurrentValue block $Exit1083073103542695 block $False1083073103542695 local.get $CurrentValue local.get $Value i32.eq br_if $False1083073103542695 br $Exit1083073103542695 end local.get $I_HashTable local.get $Hash local.get $i i32.add local.get $CapacityM1 i32.and i32.const 1 i32.shl i32.const 1 i32.or i32.add i32.const 2 i32.shl i32.load return end block $Exit739519199045886 block $False739519199045886 local.get $CurrentValue i32.const 0xffffffff i32.eq br_if $False739519199045886 br $Exit739519199045886 end i32.const 0xffffffff return end local.get $i i32.const 1 i32.add local.tee $i local.get $i local.get $Capacity i32.lt_s br_if $Continue3638738254362715 drop end end i32.const 0xffffffff return ) (func $SetSize (export "SetSize") (param $SSI i32) (result i32) (local $HeapIndex i32) (local $I_Header i32) local.get $SSI i32.const 0xffff0000 i32.and local.get $SSI i32.const 2 i32.shl i32.load i32.or local.set $HeapIndex local.get $HeapIndex i32.const 1 i32.add local.set $I_Header local.get $I_Header i32.const 2 i32.shl i32.load i32.const 16 i32.shr_s return ) (func $SetItemsListOffset (export "SetItemsListOffset") (param $SSI i32) (result i32) (local $HeapIndex i32) (local $I_Header i32) (local $Capacity i32) local.get $SSI i32.const 0xffff0000 i32.and local.get $SSI i32.const 2 i32.shl i32.load i32.or local.set $HeapIndex local.get $HeapIndex i32.const 1 i32.add local.set $I_Header local.get $I_Header i32.const 2 i32.shl i32.load i32.const 65535 i32.and local.set $Capacity local.get $HeapIndex i32.const 2 local.get $Capacity i32.const 1 i32.shl i32.add i32.add return ) )